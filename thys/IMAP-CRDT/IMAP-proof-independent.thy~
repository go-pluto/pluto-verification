theory
  "IMAP-proof-independent"
imports
  "IMAP-def"
  "IMAP-proof-helpers"	
begin
  
lemma (in imap) Broadcast_Expunge_Deliver_prefix_closed:
  assumes "xs @ [Broadcast (i, Expunge e mo i)] prefix of j"
  shows "Deliver (mo, Append mo e) \<in> set xs \<or> (\<exists> mo2 . Deliver (mo, Store e mo2 mo) \<in> set xs)"
proof -  
  obtain y where "apply_operations xs = Some y"
    using assms broadcast_only_valid_msgs by blast
  moreover hence "mo \<in> snd (y e)"
    using broadcast_only_valid_msgs[of xs "(i, Expunge e mo i)" j] valid_behaviours_def[of y "(i, Expunge e mo i)"] using assms by auto
  ultimately show ?thesis
    using assms Deliver_added_files apply_operations_added_files by blast
qed
	
lemma (in imap) Broadcast_Store_Deliver_prefix_closed:
  assumes "xs @ [Broadcast (i, Store e mo i)] prefix of j"
  shows "Deliver (mo, Append mo e) \<in> set xs \<or> (\<exists> mo2 . Deliver (mo, Store e mo2 mo) \<in> set xs)"
proof -  
  obtain y where "apply_operations xs = Some y"
    using assms broadcast_only_valid_msgs by blast
  moreover hence "mo \<in> snd (y e)"
    using broadcast_only_valid_msgs[of xs "(i, Store e mo i)" j] valid_behaviours_def[of y "(i, Store e mo i)"] using assms by auto
  ultimately show ?thesis
    using assms Deliver_added_files apply_operations_added_files by blast
qed
            
lemma (in imap) Deliver_added_ids:
  assumes "xs prefix of j"
    and "i \<in> set (added_ids xs e)"
  shows "Deliver (i, Add i e) \<in> set xs \<or> (\<exists> mo . Deliver (i, Expunge e mo i) \<in> set xs)"
using assms proof (induct xs rule: rev_induct, clarsimp)
  case (snoc x xs) thus ?case
  proof (cases x, force)
    case X: (Deliver e')
    moreover obtain a b where "e' = (a, b)" by force
    ultimately show ?thesis
      using snoc apply (case_tac b; clarify)
       apply (simp,metis added_ids_Deliver_Add_diff_collapse added_ids_Deliver_Add_same_collapse
              empty_iff list.set(1) set_ConsD add_id_valid in_set_conv_decomp prefix_of_appendD)
       apply force using  append_id_valid 
      	
       apply (simp, metis (no_types, lifting)  prefix_of_appendD)
      
      apply (simp)
       apply (metis Un_iff added_ids_Deliver_Expunge_diff_collapse added_ids_Deliver_Expunge_same_collapse empty_iff expunge_id_valid list.set(1) list.set_intros(1) prefix_of_appendD set_ConsD set_append)
        by (simp, blast)
  qed
qed

lemma (in imap) Broadcast_Deliver_prefix_closed:
  assumes "xs @ [Broadcast (r, Rem ix e)] prefix of j"
    and "i \<in> ix"
  shows "Deliver (i, Add i e) \<in> set xs \<or> Deliver (i, Append i e) \<in> set xs \<or> (\<exists> mo . Deliver (i, Expunge e mo i) \<in> set xs) \<or> (\<exists> mo . Deliver (i, Store e mo i) \<in> set xs)"
proof -  
  obtain y where "apply_operations xs = Some y"
    using assms broadcast_only_valid_msgs by blast
  moreover hence "ix = fst (y e) \<union> snd (y e)"
    by (metis (mono_tags, lifting) assms(1) broadcast_only_valid_msgs operation.case(2) option.simps(1)
     valid_behaviours_def case_prodD)
  ultimately show ?thesis
    using assms Deliver_added_ids apply_operations_added_ids
    by (metis Deliver_added_files Un_iff apply_operations_added_files le_iff_sup prefix_of_appendD)
qed
  
lemma (in imap) ids_are_unique:
    assumes "xs prefix of j"
    and "(i, Add i e1) \<in> set (node_deliver_messages xs)" 
    and "(l, Append l e2) \<in> set (node_deliver_messages xs)"
    and "(k, Expunge e3 mo k) \<in> set (node_deliver_messages xs)"
    and "(m, Store e4 mo2 m) \<in> set (node_deliver_messages xs)"
  shows "i \<noteq> l \<and> i \<noteq> k \<and> l \<noteq> k \<and> i \<noteq> m \<and> l \<noteq> m \<and> k \<noteq> m"
  	using assms delivery_has_a_cause events_before_exist prefix_msg_in_history
  	by (metis fst_conv msg_id_unique operation.distinct(15) operation.distinct(17) operation.distinct(19) operation.distinct(3) operation.distinct(5) operation.distinct(7) prod.inject) 


  		
lemma (in imap) concurrent_add_remove_independent_technical:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Add i e) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e) \<in> set (node_deliver_messages xs)"
  shows "hb (i, Add i e) (ir, Rem is e)"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (i, Add i e) \<in> set pre \<or> Deliver (i, Append i e) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1) by auto    	
  hence "Deliver (i, Add i e) \<in> set pre" using network.msg_id_unique network.delivery_has_a_cause using assms(2) assms(3) ids_are_unique
    fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD calculation 

  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD)
  ultimately show ?thesis
    using hb.intros(2) events_in_local_order by blast
qed
	
lemma (in imap) concurrent_append_remove_independent_technical:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Append i e) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e) \<in> set (node_deliver_messages xs)"
  shows "hb (i, Append i e) (ir, Rem is e)"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (i, Add i e) \<in> set pre \<or> Deliver (i, Append i e) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1) by auto
    	
  hence "Deliver (i, Append i e) \<in> set pre" using assms ids_are_unique 
  proof -
  	obtain aa :: 'a and aaa :: 'a where
  		f1: "(Deliver (i, Add i e) \<in> set pre \<or> (\<exists>a. Deliver (i, Expunge e a i) \<in> set pre) \<or> (\<exists>a. Deliver (i, Store e a i) \<in> set pre)) = (Deliver (i, Add i e) \<in> set pre \<or> Deliver (i, Expunge e aaa i) \<in> set pre \<or> Deliver (i, Store e aa i) \<in> set pre)"
  		by blast
  	have f2: "\<forall>p n pa na. Broadcast p \<notin> set (history n) \<or> Broadcast pa \<notin> set (history na) \<or> fst p \<noteq> fst pa \<or> n = na \<and> p = pa"
  		using msg_id_unique by presburger
  	obtain nn :: "'a \<times> ('a, 'b) operation \<Rightarrow> (nat \<Rightarrow> ('a \<times> ('a, 'b) operation) event list) \<Rightarrow> nat" where
  		"\<forall>x1 x3. (\<exists>v4. Broadcast x1 \<in> set (x3 v4)) = (Broadcast x1 \<in> set (x3 (nn x1 x3)))
  		
  	then have f3: "\<forall>f fa p n. \<not> network f (fa::'a \<times> ('a, 'b) operation \<Rightarrow> 'a) \<or> Deliver p \<notin> set (f n) \<or> Broadcast p \<in> set (f (nn p f))"
  		by (meson network.delivery_has_a_cause)
  	then have f4: "Broadcast (i, Append i e) \<in> set (history (nn (i, Append i e) history))"
  		using \<open>(i, Append i e) \<in> set (node_deliver_messages xs)\<close> \<open>xs prefix of j\<close> network_axioms prefix_msg_in_history by blast
  	have f5: "\<forall>es n e. \<not> es prefix of n \<or> e \<notin> set es \<or> e \<in> set (history n)"
  		using prefix_elem_to_carriers by blast
  	have f6: "pre prefix of k"
  		using calculation by blast
  	then have f7: "Deliver (i, Expunge e aaa i) \<in> set pre \<longrightarrow> nn (i, Expunge e aaa i) history = nn (i, Append i e) history \<and> (i, Expunge e aaa i) = (i, Append i e)"
  		using f5 f4 f3 f2 by (metis (no_types) fst_conv network_axioms)
  	have f8: "Deliver (i, Add i e) \<in> set pre \<longrightarrow> nn (i, Add i e) history = nn (i, Append i e) history \<and> (i, Add i e) = (i, Append i e)"
  		using f6 f5 f4 f3 f2 by (metis (no_types) fst_conv network_axioms)
  	have "Deliver (i, Add i e) \<in> set pre \<and> Deliver (i, Add i e) \<in> set pre \<or> Deliver (i, Expunge e aaa i) \<in> set pre \<and> Deliver (i, Expunge e aaa i) \<in> set pre \<or> Deliver (i, Append i e) \<in> set pre \<or> Deliver (i, Add i e) \<notin> set pre \<and> Deliver (i, Expunge e aaa i) \<notin> set pre \<and> Deliver (i, Store e aa i) \<notin> set pre"
  		using f6 f5 f4 f3 f2 by (metis (no_types) fst_conv network_axioms)
  	then show ?thesis
  		using f8 f7 f1 \<open>Deliver (i, Add i e) \<in> set pre \<or> Deliver (i, Append i e) \<in> set pre \<or> (\<exists>mo. Deliver (i, Expunge e mo i) \<in> set pre) \<or> (\<exists>mo. Deliver (i, Store e mo i) \<in> set pre)\<close> by blast
  qed
  	(*by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD)*)
  ultimately show ?thesis
    using hb.intros(2) events_in_local_order by blast
qed
	
lemma (in imap) concurrent_append_expunge_independent_technical:
  assumes "i = mo"
    and "xs prefix of j"
    and "(i, Append i e) \<in> set (node_deliver_messages xs)" and "(r, Expunge e mo r) \<in> set (node_deliver_messages xs)"
  shows "hb (i, Append i e) (r, Expunge e mo r)"
proof -
  obtain pre k where "pre@[Broadcast (r, Expunge e mo r)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (mo, Append mo e) \<in> set pre \<or> (\<exists> mo2 . Deliver (mo, Store e mo2 mo) \<in> set pre)"
    using Broadcast_Expunge_Deliver_prefix_closed assms(1) by auto
    	
  hence "Deliver (i, Append i e) \<in> set pre" using assms assms ids_are_unique
  proof -
  	obtain aa :: 'a where
  		f1: "Deliver (mo, Append mo e) \<in> set pre \<or> Deliver (mo, Store e aa mo) \<in> set pre"
  		using \<open>Deliver (mo, Append mo e) \<in> set pre \<or> (\<exists>mo2. Deliver (mo, Store e mo2 mo) \<in> set pre)\<close> by blast
  	have f2: "Deliver (mo, Append mo e) \<in> set (history j)"
  		using \<open>(i, Append i e) \<in> set (node_deliver_messages xs)\<close> \<open>i = mo\<close> \<open>xs prefix of j\<close> prefix_msg_in_history by blast
  	{ assume "Deliver (mo, Store e aa mo) \<in> set pre"
  		{ assume "v2_1 (mo, Store e aa mo) \<noteq> (v2_1 (mo, Append mo e)::nat) \<or> (mo, Store e aa mo) \<noteq> (mo, Append mo e)"
  			then have "Deliver (mo, Store e aa mo) \<notin> set pre"
  				using f2 by (metis (no_types) calculation delivery_has_a_cause fst_conv msg_id_unique prefix_elem_to_carriers prefix_of_appendD) }
  		then have "Deliver (mo, Store e aa mo) \<in> set pre \<longrightarrow> Deliver (i, Append i e) \<in> set pre"
  			by blast }
  	then show ?thesis
  		using f1 \<open>i = mo\<close> by blast
  qed
  ultimately show ?thesis
    using hb.intros(2) events_in_local_order by blast
qed

lemma (in imap) concurrent_append_store_independent_technical:
  assumes "i = mo"
    and "xs prefix of j"
    and "(i, Append i e) \<in> set (node_deliver_messages xs)" and "(r, Store e mo r) \<in> set (node_deliver_messages xs)"
  shows "hb (i, Append i e) (r, Store e mo r)"
proof -
  obtain pre k where "pre@[Broadcast (r, Store e mo r)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (mo, Append mo e) \<in> set pre \<or> (\<exists> mo2 . Deliver (mo, Store e mo2 mo) \<in> set pre)"
    using Broadcast_Store_Deliver_prefix_closed assms(1) by auto
    	
  hence "Deliver (i, Append i e) \<in> set pre" using assms(2) assms(3) ids_are_unique
  	using assms(1)
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD)
  ultimately show ?thesis
    using hb.intros(2) events_in_local_order by blast
qed
  
lemma (in imap) concurrent_expunge_remove_independent_technical:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Expunge e mo i) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e) \<in> set (node_deliver_messages xs)"
  shows "hb (i, Expunge e mo i) (ir, Rem is e)"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (i, Add i e) \<in> set pre \<or> Deliver (i, Append i e) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1) by auto
    	
  hence "Deliver (i, Expunge e mo i) \<in> set pre" using assms(2) assms(3) ids_are_unique
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD)
  ultimately show ?thesis
    using hb.intros(2) events_in_local_order by blast
qed
	
lemma (in imap) concurrent_store_remove_independent_technical:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Store e mo i) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e) \<in> set (node_deliver_messages xs)"
  shows "hb (i, Store e mo i) (ir, Rem is e)"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (i, Add i e) \<in> set pre \<or> Deliver (i, Append i e) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1) by auto
    	
  hence "Deliver (i, Store e mo i) \<in> set pre" using assms(2) assms(3) ids_are_unique
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD)
  ultimately show ?thesis
    using hb.intros(2) events_in_local_order by blast
qed
	
lemma (in imap) concurrent_store_expunge_independent_technical:
    assumes "xs prefix of j"
    and "(i, Store e mo i) \<in> set (node_deliver_messages xs)" and "(r, Expunge e i r) \<in> set (node_deliver_messages xs)"
  shows "hb (i, Store e mo i) (r, Expunge e i r)"
proof -
  obtain pre k where "pre@[Broadcast (r, Expunge e i r)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (i, Append i e) \<in> set pre \<or> (\<exists> mo2 . Deliver (i, Store e mo2 i) \<in> set pre)"
    using Broadcast_Expunge_Deliver_prefix_closed assms(1) by auto
    	
  hence "Deliver (i, Store e mo i) \<in> set pre" using assms(2) assms(3) ids_are_unique
  	by (smt assms(1) calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms node_histories.prefix_of_appendD node_histories_axioms prefix_elem_to_carriers prefix_msg_in_history)
  ultimately show ?thesis
    using hb.intros(2) events_in_local_order by blast
qed
  
lemma (in imap) expunge_rem_ids_imply_messages_same:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Expunge e1 mo i) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e2) \<in> set (node_deliver_messages xs)"
  shows "e1 = e2"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e2)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  
   moreover hence "Deliver (i, Add i e2) \<in> set pre \<or> Deliver (i, Append i e2) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e2 mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e2 mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1)
    by (meson imap.Broadcast_Deliver_prefix_closed imap_axioms)
    	
  hence "Deliver (i, Expunge e2 mo i) \<in> set pre" using assms(2) assms(3) assms(1) ids_are_unique 
  	by (smt added_files_Deliver_Append_same_collapse added_files_Deliver_Expunge_collapse added_files_Deliver_Store_same_collapse calculation delivery_has_a_cause empty_iff fst_conv list.set(1) list.set_intros(1) msg_id_unique node_histories.prefix_of_appendD node_histories_axioms operation.simps(10) operation.simps(4) prefix_elem_to_carriers prefix_msg_in_history prod.inject)
  	moreover have "Deliver(i, Expunge e1 mo i) \<in> set (history j)"
    using assms(2) assms(3) prefix_msg_in_history by blast
  ultimately show ?thesis
    by (metis (no_types, lifting) delivery_has_a_cause fst_conv network.msg_id_unique network_axioms operation.inject(4) prefix_elem_to_carriers prefix_of_appendD prod.inject)
qed
	
lemma (in imap) store_rem_ids_imply_messages_same:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Store e1 mo i) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e2) \<in> set (node_deliver_messages xs)"
  shows "e1 = e2"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e2)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  
   moreover hence "Deliver (i, Add i e2) \<in> set pre \<or> Deliver (i, Append i e2) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e2 mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e2 mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1)
    by (meson imap.Broadcast_Deliver_prefix_closed imap_axioms)
    	
  hence "Deliver (i, Store e2 mo i) \<in> set pre" using assms(2) assms(3) assms(1) ids_are_unique
  	by (smt added_files_Deliver_Store_diff_collapse added_files_Deliver_Store_same_collapse added_ids_Deliver_Expunge_same_collapse calculation empty_iff empty_set expunge_id_not_in_set fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.distinct(17) operation.distinct(19) operation.distinct(7) prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD prod.sel(2))
  	moreover have "Deliver(i, Store e1 mo i) \<in> set (history j)"
    using assms(2) assms(3) prefix_msg_in_history by blast
  ultimately show ?thesis
  	by (smt delivery_has_a_cause fst_conv network.msg_id_unique network_axioms operation.inject(5) prefix_elem_to_carriers prefix_of_appendD prod.inject)
qed

lemma (in imap) add_rem_ids_imply_messages_same:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Add i e1) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e2) \<in> set (node_deliver_messages xs)"
  shows "e1 = e2"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e2)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  moreover hence "Deliver (i, Add i e2) \<in> set pre \<or> Deliver (i, Append i e2) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e2 mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e2 mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1) ids_are_unique by blast
  hence "Deliver (i, Add i e2) \<in> set pre" using assms(1) assms(2) assms(3) ids_are_unique 
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.distinct(3) operation.distinct(5) operation.distinct(7) prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD prod.inject)
  moreover have "Deliver (i, Add i e1) \<in> set (history j)"
    using assms(2) assms(3) prefix_msg_in_history by blast
  ultimately show ?thesis
    by (metis fst_conv msg_id_unique network.delivery_has_a_cause network_axioms operation.inject(1)
        prefix_elem_to_carriers prefix_of_appendD prod.inject)
qed
	
lemma (in imap) append_rem_ids_imply_messages_same:
  assumes "i \<in> is"
    and "xs prefix of j"
    and "(i, Append i e1) \<in> set (node_deliver_messages xs)" and "(ir, Rem is e2) \<in> set (node_deliver_messages xs)"
  shows "e1 = e2"
proof -
  obtain pre k where "pre@[Broadcast (ir, Rem is e2)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  
   moreover hence "Deliver (i, Add i e2) \<in> set pre \<or> Deliver (i, Append i e2) \<in> set pre \<or> (\<exists> mo . Deliver (i, Expunge e2 mo i) \<in> set pre) \<or> (\<exists> mo . Deliver (i, Store e2 mo i) \<in> set pre)"
    using Broadcast_Deliver_prefix_closed assms(1)
    by (meson imap.Broadcast_Deliver_prefix_closed imap_axioms)
    	
  hence "Deliver (i, Append i e2) \<in> set pre" using assms(2) assms(3) assms(1) ids_are_unique
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.distinct(15) operation.distinct(17) operation.distinct(3) prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD prod.inject)
      
      
  	moreover have "Deliver (i, Append i e1) \<in> set (history j)"
    using assms(2) assms(3) prefix_msg_in_history by blast
  ultimately show ?thesis
    by (metis (no_types, lifting) fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.inject(3) prefix_elem_to_carriers prefix_of_appendD prod.inject)
qed

lemma (in imap) append_expunge_ids_imply_messages_same:
  assumes "i = mo"
    and "xs prefix of j"
    and "(i, Append i e1) \<in> set (node_deliver_messages xs)" and "(r, Expunge e2 mo r) \<in> set (node_deliver_messages xs)"
  shows "e1 = e2"
proof -
  obtain pre k where "pre@[Broadcast (r, Expunge e2 mo r)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  
   moreover hence "Deliver (mo, Append mo e2) \<in> set pre \<or> (\<exists> mo2 . Deliver (mo, Store e2 mo2 mo) \<in> set pre)"
    using Broadcast_Expunge_Deliver_prefix_closed assms(1)
    by (meson imap.Broadcast_Deliver_prefix_closed imap_axioms)
    	
  hence "Deliver (i, Append i e2) \<in> set pre" using assms(2) assms(3) assms(1) ids_are_unique 
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.distinct(17) prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD prod.inject)      
      
  	moreover have "Deliver (i, Append i e1) \<in> set (history j)"
    using assms(2) assms(3) prefix_msg_in_history by blast
  ultimately show ?thesis
    by (metis (no_types, lifting) fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.inject(3) prefix_elem_to_carriers prefix_of_appendD prod.inject)
qed
	
lemma (in imap) append_store_ids_imply_messages_same:
  assumes "i = mo"
    and "xs prefix of j"
    and "(i, Append i e1) \<in> set (node_deliver_messages xs)" and "(r, Store e2 mo r) \<in> set (node_deliver_messages xs)"
  shows "e1 = e2"
proof -
  obtain pre k where "pre@[Broadcast (r, Store e2 mo r)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  
   moreover hence "Deliver (mo, Append mo e2) \<in> set pre \<or> (\<exists> mo2 . Deliver (mo, Store e2 mo2 mo) \<in> set pre)"
    using Broadcast_Store_Deliver_prefix_closed assms(1)
    by (meson imap.Broadcast_Deliver_prefix_closed imap_axioms)
    	
  hence "Deliver (i, Append i e2) \<in> set pre" using assms(2) assms(3) assms(1) ids_are_unique 
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.distinct(17) prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD prod.inject)      
      
  	moreover have "Deliver (i, Append i e1) \<in> set (history j)"
    using assms(2) assms(3) prefix_msg_in_history by blast
  ultimately show ?thesis
    by (metis (no_types, lifting) fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.inject(3) prefix_elem_to_carriers prefix_of_appendD prod.inject)
qed
	
lemma (in imap) expunge_store_ids_imply_messages_same:
    assumes "xs prefix of j"
    and "(i, Store e1 mo i) \<in> set (node_deliver_messages xs)" and "(r, Expunge e2 i r) \<in> set (node_deliver_messages xs)"
  shows "e1 = e2"
proof -
  obtain pre k where "pre@[Broadcast (r, Expunge e2 i r)] prefix of k"
    using assms delivery_has_a_cause events_before_exist prefix_msg_in_history by blast
  
   moreover hence "Deliver (i, Append i e2) \<in> set pre \<or> (\<exists> mo2 . Deliver (i, Store e2 mo2 i) \<in> set pre)"
    using Broadcast_Expunge_Deliver_prefix_closed assms(1) by blast
    	
  hence "Deliver (i, Store e1 mo i) \<in> set pre" using assms(2) assms(3) assms(1) ids_are_unique 
  	by (smt calculation fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms operation.distinct(17) prefix_elem_to_carriers prefix_msg_in_history prefix_of_appendD prod.inject)      
      
  	moreover have "Deliver (i, Store e1 mo i) \<in> set (history j)"
    using assms(1) assms(2) prefix_msg_in_history by auto
  ultimately show ?thesis 
  	by (smt Broadcast_Expunge_Deliver_prefix_closed fst_conv network.delivery_has_a_cause network.msg_id_unique network_axioms node_histories.prefix_of_appendD node_histories_axioms operation.distinct(17) operation.inject(5) prefix_elem_to_carriers prod.inject)
qed
	
end